##2.String dp and Array dp$keywords dp  
###*String dp  
dp有几种用途，其中之一就是标记和剪枝  
  
Ex1：[LeetCode:Palindrome Partitioning](http://oj.leetcode.com/problems/palindrome-partitioning/)  
  
该题dp的作用就是标记和剪枝，使用二维dp[i][len]来表示i i+len-1之间是否有继续搜索的必要，即是否可以将i i+len-1之间的串切成回文。标记是在搜索之前判断的，之后就可dfs来搜索。

Note by [@sc703bupt](https://github.com/sc703bupt): isPalindrome方法也可以应用dp以避免重复计算，提高速度。具体做法是使用一个二维数组记录s的所有子串的是否是回文串，如dp[i][j]表示s从i到j的子串是否是回文串，求解时以每个字符为中心向两侧探测，注意奇偶情况分别求解。
```java
public class Solution {
    ArrayList<ArrayList<String>> all = new ArrayList<ArrayList<String>>();

	public ArrayList<ArrayList<String>> partition(String s) {
		all.clear();
		int length = s.length();
		boolean[][] seg = new boolean[length][length + 1];
		for (int len = 1; len <= length; len++) {
			for (int i = 0; i < length - len + 1; i++) {
				String t = s.substring(i, i + len);
				if (isPalindrome(t)) {
					seg[i][len] = true;
					continue;
				}
				for (int k = 1; k < len; k++) {
					if (seg[i][k] && seg[i + k][len - k]) {
						seg[i][len] = true;
						break;
					}
				}
			}
		}

		part(s, seg, 0, 0, new ArrayList<String>());
		return all;
	}

	public void part(String s, boolean[][] seg, int start, int depth,
			ArrayList<String> list) {
		int length = s.length();
		if (depth == length) {
			ArrayList<String> listCopy = new ArrayList<String>(list);
			all.add(listCopy);

			return;
		}
		for (int len = 1; len <= length; len++) {
			if (seg[start][len]) {
				String word = s.substring(start, start + len);
				// System.out.println(word);
				if (isPalindrome(word)) {
					list.add(word);
					part(s, seg, start + len, start + len, list);
					list.remove(list.size() - 1);
				}
			}
		}

	}

	public boolean isPalindrome(String s) {
		for (int i = 0; i < s.length() / 2; i++)
			if (s.charAt(i) != s.charAt(s.length() - i - 1))
				return false;
		return true;
	}
}
``` 
isPalindrome的dp解法：
```cpp
    void isPalindrome(string str){
	int len = str.length();
	bool isPalindrome[len][len];
	for(int i = 0; i <= len - 1; i++){//init
		for(int j = 0; j <= len - 1; j++){
			isPalindrome[i][j] = false;
		}
	}
	for(int i = 0; i <= len - 1; i++){
		for(int j = 0; j <= min(len-1-i,i); j++){
			if(str[i-j]==str[i+j]){
				isPalindrome[i-j][i+j] = true;
			}else{
				break;
			}
		}
		if(i+1<=len-1){
			for(int k = 0; k <= min(len-2-i,i); k++){
				if(str[i-k]==str[i+1+k]){
					isPalindrome[i-k][i+1+k] = true;
				}else{
					break;
				}
			}
		}
	}
```
dp的作用其二，记录状态。一般记录int状态或boolean状态，当前状态由上一个状态得到，二维dp[i][j]中的i j也不再局限于字符串的数组下标i j，而有可能是从0到某个最大值，或者从0到某个最大和  
  
Ex2：[LeetCode:Interleaving String](http://oj.leetcode.com/problems/interleaving-string/)(Removed)  
  
此题中dp[i][j]表达的意思是s3中的前（i+j）长度串是否为 s1中的前i长度串 与 s2中的前j长度串 混合组成，使用boolean记录。
若s3的前i+j-1串已经和s1的前i串与s2的前j-1串匹配，此时若s2的第j个字符和s3的第i+j个字符相等，则说明s3的i+j串和s1的i串与s2的j串匹配。s1的i-1加s2的j同理  
```java  
public class Solution {
	public boolean isInterleave(String s1, String s2, String s3) {
		if (s3.length() != s1.length() + s2.length())
			return false;
		if (s1.length() == 0)
			if (!s2.equals(s3))
				return false;
			else
				return true;
		if (s2.length() == 0)
			if (!s1.equals(s3))
				return false;
			else
				return true;
		boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
		dp[0][0] = true;

		for (int i = 1; i <= s1.length(); i++)
			if (dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1))
				dp[i][0] = true;

		for (int j = 1; j <= s2.length(); j++)
			if (dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1))
				dp[0][j] = true;

		for (int i = 1; i <= s1.length(); i++)
			for (int j = 1; j <= s2.length(); j++) {
				if (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1))
					dp[i][j] = true;
				if (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1))
					dp[i][j] = true;
			}

		return dp[s1.length()][s2.length()];
	}

	public static void main(String[] args) {
		Solution m = new Solution();
		String s1 = "aabccabc";
		String s2 = "dbbabc";
		String s3 = "aabdbbccababcc";
		boolean result = m.isInterleave(s1, s2, s3);
		System.out.print(result);
	}
}
```  
  
Ex3：[LeetCode:Wildcard Matching](http://oj.leetcode.com/problems/wildcard-matching/)  
  
又是一道字符串匹配的题。这道题dp[j][i]表达的意思是s1长度为i的串是否和s2中长度为j的串匹配。但这道题有一个小技巧，就是用s2的字符去匹配s1的字符。当s2的第j个字符是\*时，这里有两种选择：既可以让\*去匹配s1的一个字符，使i前进1，也可以把*当成空白，此时dp[j][i]的状态就等于dp[j-1][i]的状态。当s2遇到?时，和s1的第i个字符与s2的第j个字符相等是等效的，此时dp[j][i]=dp[j-1][i-1]  
```cpp  
class Solution {   
public:   
  bool isMatchDp(string& t, string& p){
	int tLen = t.length();
	int pLen = p.length();
	
	bool dp[pLen+1][tLen+1];
	memset(dp, 0, sizeof(dp));
	
	dp[0][0] = true;
	
	for(int i = 1; i <= pLen; i++){
		if(dp[i-1][0]&&p[i-1]=='*'){
			dp[i][0] = true;
		}
	}
	
	for(int i = 1; i <= pLen; i++){
		for(int j = 1; j <= tLen; j++){
			if((p[i-1] == '?')||p[i-1] == t[j-1]){
				dp[i][j] = dp[i-1][j-1];
			}else if(p[i-1] == '*'){
				dp[i][j] = dp[i-1][j]||dp[i][j-1];
			}else{
				dp[i][j] = false;
			}
		}
	}
	
	return dp[pLen][tLen];
    }
};   
```  

附该题的递归解法，时间复杂度高于dp方法，但是一个比较直观的思路。
```cpp
//recursive
bool isMatch(string& t, string& p, int tPtr, int pPtr){
	if(p.length() == pPtr&&t.length() == tPtr) return true;
	if(t.length() == tPtr||p.length() == pPtr) return false;
	
	if(p[pPtr] == '?'){
		return isMatch(t, p, tPtr+1, pPtr+1);
	}else if(p[pPtr] == '*'){
		int tempPtr = tPtr;
		while(tempPtr != t.length()+1){
			if(isMatch(t, p, tempPtr, pPtr+1)){
				return true;
			}
			tempPtr++;
		}
		return false;
	}else if(p[pPtr] == t[tPtr]){
		return isMatch(t, p, tPtr+1, pPtr+1);
	}else{
		return false;
	}
}
```

Ex4：[LeetCode:Edit Distance](http://oj.leetcode.com/problems/edit-distance/)  
  
两个字符串的最小距离。在本题中，dp同时起到了标记和记录状态的作用，表示s1中前面长度为i的串和s2中前面长度为j的串匹配的最小距离。用过dfs的同学都知道，一般dfs是当遍历到末尾才开始返回值的，本题dfs的目的就是返回dp[i][j]的最小值。既然返回的是最小值，所以对于每一个dp[i][j]来说，只要遍历过一遍就够了，第一次遍历赋值，第二次遍历到dp[i][j]直接返回dp[i][j]的值。然后关注当前状态dp[i][j]。若s1中第i个字符和s2中第j个字符相等，dp[i][j]=dp[i-1][j-1]，自然不用说；若不相等，则分成了增删改三种情况：增的话j+1，相当于在s1中加了一个字符与s2中第j个字符匹配；删，i+1，s1第i个字符被删掉，用s1第i+1个与s2第j个字符匹配；改，改后s1第i个字符等于s2第j个字符，i+1，j+1。以上三种情况匹配距离都要加一。然后取出三者中小的赋给dp[i][j]。

Add by[@sc703bupt](https://github.com/sc703bupt): 给出一种“正向”迭代式dp解法，c++代码。
```java  
public class Solution {
	public int minDistance(String word1, String word2) {
		if (word1.length() == 0)
			return word2.length();
		if (word2.length() == 0)
			return word1.length();
		int[][] dp = new int[word1.length()][word2.length()];
		int result = search(0, 0, word1, word2, dp);
		return result;
	}

	public int search(int i, int j, String s1, String s2, int[][] dp) {
		if (i == s1.length())
			return s2.length() - j;
		if (j == s2.length())
			return s1.length() - i;
		if (dp[i][j] != 0)
			return dp[i][j];
		if (s1.charAt(i) == s2.charAt(j)) {
			int tmp = search(i + 1, j + 1, s1, s2, dp);
			dp[i][j] = tmp;
			return tmp;
		}
		int tmp1 = search(i, j + 1, s1, s2, dp) + 1;
		int tmp2 = search(i + 1, j, s1, s2, dp) + 1;
		int tmp3 = search(i + 1, j + 1, s1, s2, dp) + 1;
		int result = tmp1;
		if (result > tmp2)
			result = tmp2;
		if (result > tmp3)
			result = tmp3;
		dp[i][j] = result;
		return result;
	}
}
```
迭代式dp解法:
```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int> > record;
        record.resize(word1.size()+1);
        for(int i = 0; i <= word1.size(); i++){
            for(int j = 0; j <= word2.size(); j++){
                record[i].push_back(0);
            }
            //record.push_back(vector<int>(word2.size()+1));
            record[i][0] = i;
        }
        for(int j = 0; j <= word2.size(); j++){
            record[0][j] = j;
        }
        int tempMin = 0, subVal = 0;
        for(int i = 1; i <= word1.size(); i++){
            for(int j = 1; j <= word2.size(); j++){
                tempMin = record[i][j-1] + 1;//add
                tempMin = tempMin < record[i-1][j] + 1?tempMin:record[i-1][j] + 1;//delete
                subVal = ((word1[i-1] == word2[j-1])?0:1);//judge current char word1[i] and word2[j] 
                tempMin = tempMin < record[i-1][j-1] + subVal?tempMin:record[i-1][j-1] + subVal;//revise
                record[i][j] = tempMin;
            }
        }
        return record[word1.size()][word2.size()];
    }
};
```
###*Array dp  
  
Ex5:最长公共子序列（LCS）：请编写一个函数，输入两个字符串，求它们的最长公共子序列长度，并打印出最长公共子序列。  
  
经典的动态规划问题。dp[i][j]表示p1的前i的个字符和p2的前j个字符匹配的最大长度。定位到dp[i][j]。若p1中的第i个字符与p2的第j个字符相等，则dp[i][j]=dp[i-1][j-1]+1;若不相等，则为dp[i-1][j]和dp[i][j-1]中较大的一个。关键问题是如何打印最长公共子序列。这里我们可以再使用一个二维数组mark来标记当前的状态是从哪一个状态得来。mark[i][j]有三个值，分别为1 2 3,1表示由dp[i-1][j]得来，2表示由dp[i-1][j-1]得来，3表示由dp[i][j-1]得来。当得到最长公共子序列的长度后，dp[p1.length()-1][p2.length()-1]开始向前查找，mark[i][j]为1 i--，为3 j--，为2 i-- j--并将当前值填入结果数组。最后将数组逆序输出即可。  
```java  
import java.util.ArrayList;

public class MyOwn {
	public void LCS(char[] a, char[] b) {
		int len1 = a.length;
		int len2 = b.length;
		int[][] dp = new int[len1 + 1][len2 + 1];
		char[][] mark = new char[len1 + 1][len2 + 1];

		for (int i = 0; i <= len1; i++)
			dp[i][0] = 0;
		for (int i = 0; i <= len2; i++)
			dp[0][i] = 0;
		for (int i = 1; i <= len1; i++)
			for (int j = 1; j <= len2; j++) {
				if (a[i - 1] == b[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
					mark[i][j] = '2';
				} else {
					if (dp[i][j - 1] >= dp[i - 1][j]) {
						dp[i][j] = dp[i][j - 1];
						mark[i][j] = '3';
					} else {
						dp[i][j] = dp[i - 1][j];
						mark[i][j] = '1';
					}
				}
			}

		System.out.println(dp[len1][len2]);
		ArrayList<Integer> l = new ArrayList<Integer>();
		int i = len1;
		int j = len2;
		while (i >= 0 && j >= 0) {
			if (mark[i][j] == '1')
				i--;

			else if (mark[i][j] == '3')
				j--;

			else {
				l.add(i);
				i--;
				j--;
			}
		}
		for (i = l.size() - 1; i >= 0; i--)
			System.out.print(a[l.get(i)] + " ");
	}

	public static void main(String[] args) {
		MyOwn m = new MyOwn();
		char[] a = { 'c', 'n', 'b', 'l', 'o', 'g', 's' };
		char[] b = { 'b', 'e', 'l', 'o', 'n', 'g' };
		m.LCS(a, b);
	}
}
```  
  
Ex6:最长上升子序列（LIS）：给出一个序列a1,a2,a3,a4,a5,a6,a7….an,求它的一个子序列（设为s1,s2,…sn），使得这个子序列满足这样的性质，s1,s2,s3…sn递增并且这个子序列的长度最长。输出这个最长的长度。  
  
又一个经典的动态规划问题。不同的是这次使用的是一维数组，空间复杂度下降了，dp依旧记录状态，只不过记录的状态很特别，dp[i]
=j表示长度为i的递增子序列的最后一个数是j。在对原数组遍历的过程中，每一次都要将a[i]更新到dp的对应位置去。比如a[4]=3，而dp[1]=2，dp[2]=4,表示长度为1的递增子序列最后一个数是2,长度为2的递增子序列最后一个数是4，此时就可以将dp[2]更新为3,因为长度为1的递增子序列最后一位为2,3大于2，所以序列长度加一，最后一位为3,3小于4，所以将dp[2]更新为3.由此可见dp是一个单调递增数组，所以在修改的时候可以采用二分查找，这样时间复杂度就降为nlogn。如果dp中没有比a[i]大的，则说明最长递增子序列的长度增加了一位。

Add by[@sc703bupt](https://github.com/sc703bupt): 实际上[@popolou](https://github.com/popolou)的解法是贪心法，使用了一个栈模拟当前最大递增子序列的长度，当元素大于栈顶，最长序列+1，否则替换第一个比该元素大的栈内元素，保持栈内序列的“最大潜力”，该解法的时间复杂度为O(nlgn)。例如对于1,2,3,6,4序列，1、2和3顺序入栈，代表当前最大长度为3，当遍历到6时，仍然大于栈顶，入栈，当前最大长度为4，当遍历到4时，寻找第一个比4大的元素并替换，栈内为1,2,3,4，故最大长度为4

Add by[@sc703bupt](https://github.com/sc703bupt): 等效问题：求解一个数列中需要调整的最少次数使得该数列有序，一次调整操作如将1,2,4,6,5,3变换为1,2,3,4,6,5。

```java
import java.util.ArrayList;

public class MyOwn1 {
	public void LIS(int[] a) {
		int len = a.length;
		int[] b = new int[len + 1];
		b[1] = a[0];
		int max = 1;
		ArrayList<Integer> result = new ArrayList<Integer>();
		for (int i = 1; i < len; i++) {
			int start = 1;
			int end = max;
			while (start <= end) {
				int middle = (start + end) / 2;
				if (b[middle] < a[i])
					start = middle + 1;
				else if (b[middle] > a[i])
					end = middle - 1;
			}
			b[start] = a[i];
			if (start > max) {
				max++;
				result.clear();
				for (int j = 1; j <= max; j++)
					result.add(b[j]);
			}
		}
		System.out.println("result: " + max);
		System.out.println(result);
	}

	public static void main(String[] args) {
		MyOwn1 m = new MyOwn1();
		int[] a = { 2, 1, 5, 3, 6, 4, 8, 9, 7 };
		m.LIS(a);
	}
}
```
  
Ex7:将数组分成元素个数相等，和最接近的两部分，求和的较大值    

dp可以有两种状态，boolean和int，这两种方法都可以用来解决这道题。  
首先看int dp。二维dp[i][j]中，i和j不再表示数组下标。dp[i][j]表示取i件物品，总和不超过j的最大值是多少。关注dp[i][j]。遍历到某一件物品k，若状态dp[i-1][j-a[k]]=m（表示可以到达该状态），则dp[i][j]可以为m+a[k]，但我们并不能确定dp[i][j]为最大值，因为可能已经通过别的方式到达dp[i][j]，所以dp[i][j]=max(dp[i-1][j-a[k]]+a[k],dp[i][j])，表示这第k件物品可加可不加。    
再看boolean dp。dp[i][j]表示是否可以找到i个数，使他们的和等于j。依旧关注dp[i][j]。对于一件物品k，若状态dp[i-1][j-a[k]]可达到，则dp[i][j]可达到。  
  
```java

public class Solution {
	int arr[] = { 0, 1, 5, 7, 8, 9, 6, 3, 11, 20, 17 };
	int N = 5;
	int SUM = 87;

	int solve2() {
		int i, j, s;
		int[][] dp = new int[N + 1][SUM / 2 + 2];

		for (i = 1; i <= 2 * N; ++i) {
			// for (j = 1; j <= Math.min(i, N); ++j) {
			for (j = 1; j <= N; ++j) {
				for (s = SUM / 2 + 1; s >= arr[i]; --s) // 01背包从大到小，可以省空间，即最外层的空间
				{
					dp[j][s] = Math.max(dp[j - 1][s - arr[i]] + arr[i],
							dp[j][s]);
				}
			}
		}
		return dp[N][SUM / 2 + 1];
	}

	int solve3() {
		int i, j, s;
		int[][] isOK = new int[N + 1][SUM / 2 + 2]; // isOK[i][v]表示是否可以找到i个数，使得它们之和等于v
		// 注意初始化
		isOK[0][0] = 1; // 可以,取0件物品，总合为0，是合法的

		for (i = 1; i <= 2 * N; ++i) {
			for (j = 1; j <= Math.min(i, N); ++j) {
				for (s = SUM / 2 + 1; s >= arr[i]; --s) // 从大到小，数组少了一维
				{
					if (isOK[j - 1][s - arr[i]] == 1)
						isOK[j][s] = 1;
				}
			}
		}
		for (s = SUM / 2 + 1; s >= 0; --s) {
			if (isOK[N][s] == 1)
				return s;
		}
		return 0;
	}
}
```
  
Ex8:求随机数构成的数组中最长的等差数列, 输出等差数列由小到大  

这道题的dp[i][j]就更有点神奇了，dp[i][j]表示以数组中第i个元素结尾，等差之差为j的等差数列的长度。由此可以看出在选择dp的i和j时是非常有讲究的。最好放入你认为关系重要的变量，并且dp[i][j]=k中只用i j k三个变量就可以完整的描述各种变化。接下来依旧关注dp[i][j]。什么状态能够达到dp[i][j]呢？j是等差之差，i是最后一个元素。如果能有a[i]-a[t]=j的话，那么dp[t][j]就应该能达到dp[i][j]，并且dp[i][j]有可能等于dp[t][j]+1，因为和之前题目中的原因一样，有可能这个状态在之前已经被遍历过了，有更大的值，所以dp[i][j]=max(dp[t][j]+1,dp[i][j])。又，如果dp[i][j]大于我们记录的等差数列长度的最大值，则更新等差数列长度最大值，同时记录等差数列最后一个元素，等差之差。有了这三个元素就可以推出整个等差数列的元素。  

```java
public class MyOwn {
	public void solve4(int[] a) {
		int len = a.length;
		int maxv = Integer.MIN_VALUE;
		int minv = Integer.MAX_VALUE;
		for (int i : a) {
			if (i > maxv)
				maxv = i;
			if (i < minv)
				minv = i;
		}
		int max = maxv - minv;
		int[][] dp = new int[len][max + 1];
		for (int i = 0; i < len; i++)
			for (int j = 0; j <= max; j++)
				dp[i][j] = 1;
		int ans = 0;
		int end = 0;
		int dist = 0;

		for (int i = 1; i < len; i++)
			for (int j = 0; j <= i - 1; j++) {
				int temp = a[i] - a[j];
				if (temp > 0) {
					dp[i][temp] = Math.max(dp[j][temp] + 1, dp[i][temp]);
					if (dp[i][temp] > ans) {
						ans = dp[i][temp];
						end = i;
						dist = temp;
					}
				}
			}

		System.out.println("result: " + ans);
		int start = a[end] - (ans - 1) * dist;
		for (int i = 0; i < ans; i++)
			System.out.print(start + i * dist + " ");
		System.out.println();
	}
}
```
  
Ex9:[Leetcode:Distinct Subsequences](http://oj.leetcode.com/problems/distinct-subsequences/)  
二维数组dp[T][S]，用来记录匹配子序列的个数。
* dp[0][0] = 1;  T和S都是空串
* dp[0][1 ... S.length() - 1] = 1;  T是空串，S只有一种子序列匹配
* dp[1 ... T.length() - 1][0] = 0;  S是空串，T不是空串，S没有子序列匹配
* dp[i][j] = dp[i][j - 1] + (T[i - 1] == S[j - 1] ? dp[i - 1][j - 1] : 0).1 <= i <= T.length(), 1 <= j <= S.length()
```cpp
public class Solution {
	public int numDistinct(String S, String T) {
		// Start typing your Java solution below
		// DO NOT write main() function
		int[][] dp = new int[T.length() + 1][S.length() + 1];
		dp[0][0] = 1;
		for (int i = 1; i <= T.length(); i++) {
			dp[i][0] = 0;
		}
		for (int j = 1; j <= S.length(); j++) {
			dp[0][j] = 1;
		}
		for (int i = 1; i <= T.length(); i++) {
			for (int j = 1; j <= S.length(); j++) {
				dp[i][j] = dp[i][j - 1];
				if (T.charAt(i - 1) == S.charAt(j - 1)) {
					dp[i][j] += dp[i - 1][j - 1];
				}
			}
		}
		return dp[T.length()][S.length()];

	}
}
```
